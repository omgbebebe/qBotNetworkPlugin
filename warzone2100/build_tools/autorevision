#!/bin/sh

# Copyright (c) 2012 - 2013 dak180 and contributors. See
# http://opensource.org/licenses/mit-license.php or the included
# COPYING.md for licence terms.
#
# autorevision - extracts metadata about the head version from your
# repository.

# Usage message.
arUsage() {
	cat > "/dev/stderr" << EOF
usage: ./autorevision {-t output-type | -s symbol} [-o cache-file [-f] ] [-V]
	Options include:
	-t output-type		= specify output type
	-s symbol		= specify symbol output
	-o cache-file		= specify cache file location
	-f			= force the use of cache data
	-V			= emit version and exit
	-?			= help message

The folowing are valid output types:
	h			= Header for use with c/c++
	xcode			= Header useful for populating info.plist files
	sh			= Bash sytax

The following are valid symbols:
	VCS_TYPE
	VCS_BASENAME
	VCS_BRANCH
	VCS_TAG
	VCS_EXTRA
	VCS_FULL_HASH
	VCS_SHORT_HASH
	VCS_WC_MODIFIED
EOF
	exit 1
}

# Config
ARVERSION="1.7-Warzone"
TARGETFILE="/dev/stdout"
while getopts ":t:o:s:Vf" OPTION; do
	case "${OPTION}" in
		t)
			AFILETYPE="${OPTARG}"
		;;
		o)
			CACHEFILE="${OPTARG}"
		;;
		f)
			CACHEFORCE="1"
		;;
		s)
			VAROUT="${OPTARG}"
		;;
		U)
			UNTRACKEDFILES="1"
		;;
		V)
			echo "autorevision ${ARVERSION}"
			exit 0
		;;
		?)
			# If an unknown flag is used (or -?):
			arUsage
		;;
	esac
done

if [ ! -z "${VAROUT}" ] && [ ! -z "${AFILETYPE}" ]; then
	# If both -s and -t are specified:
	echo "error: Improper argument combination." 1>&2
	exit 1
elif [ -z "${VAROUT}" ] && [ -z "${AFILETYPE}" ]; then
	# If neither -s or -t are specified:
	arUsage
elif [ -z "${CACHEFILE}" ] && [ "${CACHEFORCE}" = "1" ]; then
	# If -f is specified without -o:
	arUsage
fi

# Make sure that the path we are given is one we can source
# (dash, we are looking at you).
if ! echo "${CACHEFILE}" | grep -q '^\.*/'; then
	CACHEFILE="./${CACHEFILE}"
fi


# Functions to extract data from different repo types.
# For git repos
gitRepo() {
	cd "$(git rev-parse --show-toplevel)"

	VCS_TYPE="git"
	VCS_BASENAME="$(basename "${PWD}")"

	# Check if working copy is clean, however, we will ignore any and all po files
	# when we determine if modifications were done.
	git update-index --assume-unchanged po/*.po
	test -z "$(git status --untracked-files=no --porcelain)"
	VCS_WC_MODIFIED="${?}"
	# now, reset index back to normal
	git update-index --no-assume-unchanged po/*.po

	# The full revision hash
	VCS_FULL_HASH="$(git rev-parse HEAD)"
	# The short hash
	VCS_SHORT_HASH="$(echo "${VCS_FULL_HASH}" | cut -b 1-7)"
	# Current branch (if we are on a branch...)
	VCS_BRANCH="$(git symbolic-ref --short -q HEAD)"
	# Check if we are on a tag
	VCS_TAG="$(git describe --exact-match 2> /dev/null)"
	# get some extra data in case we are not on a branch or a tag...
	VCS_EXTRA="$(git describe 2> /dev/null)"
}


# Functions to output data in different formats.
# For header output
hOutput() {
	cat > "${TARGETFILE}" << EOF
/* Generated by autorevision - do not hand-hack! */
#ifndef AUTOREVISION_H
#define AUTOREVISION_H

#define VCS_TYPE		"${VCS_TYPE}"
#define VCS_BASENAME	"${VCS_BASENAME}"
#define VCS_BRANCH		"${VCS_BRANCH}"
#define VCS_TAG			"${VCS_TAG}"
#define VCS_EXTRA       "${VCS_EXTRA}"


#define VCS_FULL_HASH		"${VCS_FULL_HASH}"
#define VCS_SHORT_HASH		"${VCS_SHORT_HASH}"

#define VCS_WC_MODIFIED		${VCS_WC_MODIFIED}

#endif

/* end */
EOF
}

# A header output for use with xcode to populate info.plist strings
xcodeOutput() {
	cat > "${TARGETFILE}" << EOF
/* Generated by autorevision - do not hand-hack! */
#ifndef AUTOREVISION_H
#define AUTOREVISION_H

#define VCS_TYPE		${VCS_TYPE}
#define VCS_BASENAME	${VCS_BASENAME}
#define VCS_BRANCH		${VCS_BRANCH}
#define VCS_TAG			${VCS_TAG}
#define VCS_EXTRA       ${VCS_EXTRA}

#define VCS_FULL_HASH		${VCS_FULL_HASH}
#define VCS_SHORT_HASH		${VCS_SHORT_HASH}

#define VCS_WC_MODIFIED		${VCS_WC_MODIFIED}

#endif

/* end */
EOF
}

# For bash output
shOutput() {
	cat > "${TARGETFILE}" << EOF
# Generated by autorevision - do not hand-hack!

VCS_TYPE="${VCS_TYPE}"
VCS_BASENAME="${VCS_BASENAME}"
VCS_BRANCH="${VCS_BRANCH}"
VCS_TAG="${VCS_TAG}"
VCS_EXTRA="${VCS_EXTRA}"

VCS_FULL_HASH="${VCS_FULL_HASH}"
VCS_SHORT_HASH="${VCS_SHORT_HASH}"

VCS_WC_MODIFIED=${VCS_WC_MODIFIED}

# end
EOF
}
# Detect and collect repo data.
if [ -f "${CACHEFILE}" ] && [ "${CACHEFORCE}" = "1" ]; then
	# When requested only read from the cache to populate our symbols.
	. "${CACHEFILE}"
elif [ ! -z "$(git rev-parse HEAD 2>/dev/null)" ]; then
	gitRepo
elif [ -f "${CACHEFILE}" ]; then
	# We are not in a repo; try to use a previously generated cache to populate our symbols.
	. "${CACHEFILE}"
	# Do not overwrite the cache if we know we are not going to write anything new.
	CACHEFORCE="1"
else
	echo "error: No repo or cache detected." 1>&2
	exit 1
fi


# -s output is handled here.
if [ ! -z "${VAROUT}" ]; then
	if [ "${VAROUT}" = "VCS_TYPE" ]; then
		echo "${VCS_TYPE}"
	elif [ "${VAROUT}" = "VCS_BASENAME" ]; then
		echo "${VCS_BASENAME}"
	elif [ "${VAROUT}" = "VCS_BRANCH" ]; then
		echo "${VCS_BRANCH}"
	elif [ "${VAROUT}" = "VCS_TAG" ]; then
		echo "${VCS_TAG}"
	elif [ "${VAROUT}" = "VCS_EXTRA" ]; then
		echo "${VCS_EXTRA}"
	elif [ "${VAROUT}" = "VCS_FULL_HASH" ]; then
		echo "${VCS_FULL_HASH}"
	elif [ "${VAROUT}" = "VCS_SHORT_HASH" ]; then
		echo "${VCS_SHORT_HASH}"
	elif [ "${VAROUT}" = "VCS_WC_MODIFIED" ]; then
		echo "${VCS_WC_MODIFIED}"
	else
		echo "error: Not a valid output symbol." 1>&2
		exit 1
	fi
fi

# Detect requested output type and use it.
if [ ! -z "${AFILETYPE}" ]; then
	if [ "${AFILETYPE}" = "h" ]; then
		hOutput
	elif [ "${AFILETYPE}" = "xcode" ]; then
		xcodeOutput
	elif [ "${AFILETYPE}" = "sh" ]; then
		shOutput
	else
		echo "error: Not a valid output type." 1>&2
		exit 1
	fi
fi


# If requested, make a cache file.
if [ ! -z "${CACHEFILE}" ] && [ ! "${CACHEFORCE}" = "1" ]; then
	TARGETFILE="${CACHEFILE}"
	shOutput
fi
